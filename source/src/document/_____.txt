＊evsworks.h に追加した構造体に関しての説明

//------------------------------------------------------------------------------------
//	ゲーム情報用構造体
typedef	struct	{
	s8	pos_m_x,pos_m_y;	//	表示座標(8 x 16)
	s8	capsel_m_g;			//	カプセルのグラフィック番号
	s8	capsel_m_p;			//	カプセルのパレット番号
	s8	capsel_m_flg[6];	//	カプセルの表示フラグと落下判定フラグ
}game_map;

上記の構造体はマップ(瓶の中身)情報の構造体で、１つのマップあたり 128(8×16)の配列になっており、
evsworks.c で game_map	game_map_data[4][8 << 4] と定義されています。


pos_m_x と pos_m_y は瓶の座標(横８×縦１６)を指していますが、取る値が違うので注意して下さい。
pos_m_x は 0 〜 ７ で pos_m_y は 1 〜 16 です。

図にすると以下のようになります


Ｘ→   0      1      2      3      4      5      6      7

Ｙ	配列番号
↓	  ↓
 1	{ 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07 }
 2	{ 0x08 | 0x09 | 0x0a | 0x0b | 0x0c | 0x0d | 0x0e | 0x0f }
 3	{ 0x10 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 }
 4	{ 0x18 | 0x19 | 0x1a | 0x1b | 0x1c | 0x1d | 0x1e | 0x1f }
 :	   ::     ::     ::     ::     ::     ::     ::     ::
 :	   ::     ::     ::     ::     ::     ::     ::     ::
 :	   ::     ::     ::     ::     ::     ::     ::     ::
 :	   ::     ::     ::     ::     ::     ::     ::     ::
 :	   ::     ::     ::     ::     ::     ::     ::     ::
13	{ 0x60 | 0x61 | 0x62 | 0x63 | 0x64 | 0x65 | 0x66 | 0x67 }
14	{ 0x68 | 0x69 | 0x6a | 0x6b | 0x6c | 0x6d | 0x6e | 0x6f }
15	{ 0x70 | 0x71 | 0x72 | 0x73 | 0x74 | 0x75 | 0x76 | 0x77 }
16	{ 0x78 | 0x79 | 0x7a | 0x7b | 0x7c | 0x7d | 0x7e | 0x7f }


例えば	X = 1,Y = 14 の配列番号を求める場合

	配列番号 = (Y << 3) + X で求まります


capsel_m_g はグラフィックの番号を指します。

dm_game_main.h で定義されている下記の変数がグラフィックの番号( 状態 )になります。
enum	{
	capsel_u,		//	カプセル	上
	capsel_d,		//				下
	capsel_l,		//				左
	capsel_r,		//				右
	capsel_b,		//				ボール
	erase_cap_a,	//				消滅１
	erase_cap_b,	//				消滅２
	virus_a1,		//	ウイルス	a1
	virus_a2,		//				a2
	virus_b1,		//				b1
	virus_b2,		//				b2
	virus_c1,		//				c1
	virus_c2,		//				c2
	erase_virus_a,	//				消滅１
	erase_virus_b,	//				消滅２
	no_item,		//	何も無し
	virus_a3,		//				a3
	virus_a4,		//				a4
	virus_b3,		//				b3
	virus_b4,		//				b4
	virus_c3,		//				c3
	virus_c4		//				c4
};

capsel_m_p は、パレット番号になります。
dm_game_main.h で定義されている下記の変数がパレットの番号( 色 )になります。
enum	{
	capsel_red,			//	カプセル	赤
	capsel_yellow,		//				黄
	capsel_blue,		//				青
	capsel_b_red,		//			暗い赤
	capsel_b_yellow,	//			暗い黄
	capsel_b_blue,		//			暗い青
};

capsel_m_flg[6]	は、その位置の情報です
配列番号
	0：	表示フラグで １ のとき表示 ０ のとき非表示( 何も無い )です。
	1：	落下フラグで １ のとき落下 ０ のときは落下しません。
	2：	状態フラグで １ のとき消滅状態になります。通常は ０ です。
	3：	色識別フラグで パレット番号の ０ 〜 ２ までが入る。( 暗い色は入らない )
	4：	ウイルス判別用フラグで -1 以下の場合は カプセルで ０ 以上の場合ウイルスになります( 0:赤 1:黄 2:青 )。
	5：	現在未使用


//------------------------------------------------------------------------------------



//------------------------------------------------------------------------------------
//	落下カプセル用構造体
typedef	struct	{
	s8	pos_x[2],pos_y[2];	//	表示座標(8 x 16)
	s8	capsel_g[2];		//	カプセルのグラフィック番号
	s8	capsel_p[2];		//	カプセルのパレット番号
	s8	capsel_flg[4];		//	カプセルの表示フラグと落下判定フラグ
}game_cap;


上記は、操作するカプセルの情報用の構造体です。

pos_x,pos_y はカプセルの座標(横８×縦１６)を指すようになっています。
配列の 0 が左側、1 が右側の座標となります。
なお、pos_y の値が０の時は NEXT(落下待ち) になります。

capsel_p は、パレット番号、capsel_g は、グラフィック番号になり、
game_map 型の capsel_m_p と capsel_m_g と同じ扱いになります。
配列の 0 が左側、1 が右側のカプセルとなります。

capsel_flg[4]	は、その落下カプセルの情報です
配列番号
	0：	表示フラグで １ のとき表示 ０ のとき非表示です。
	1：	落下フラグで １ のとき落下 ０ のときは落下しません。
	2：	現在未使用
	3：	現在未使用
//------------------------------------------------------------------------------------


//	攻撃カプセル用構造体
typedef	struct	{
	s8	pos_a_x,pos_a_y;	//	表示座標(8 x 16)
	s8	capsel_a_p;			//	カプセルのパレット番号
	s8	capsel_a_flg[3];	//	カプセルの表示フラグと落下判定フラグ
}game_a_cap;

上記の構造体は、操作説明使用。
//------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------
//	キャラクタ( マリオ・ノコノコ等 )のデータ構造体
typedef	struct{
	u16	*anime_pal;			//	パレットポインタ
	u8	*anime_dat;			//	グラフィックポインタ
	s8	pos_an_x,pos_an_y;	//	座標
	u8	def_w_size;			//	横幅
	u8	def_h_size;			//	縦幅
	u8	h_size[3];			//	0:分割１ 1:分割２ 2:分割３
	u8	aniem_wait;			//	表示時間
	s8	aniem_flg;			//	フラグ
}game_anime_data;

上記構造体は、キャラクターのアニメーションデータ( １コマ ）の構造体です。

*anime_pal	は、そのグラフィックに使うパレットのアドレスを指します。
*anime_dat	は、グラフィックのアドレスをさしています。
配列の 0 が上半分の先頭のアドレス、 1 が下半分の先頭のアドレスをさします。

pos_an_x,pos_an_y はビーアニで設定された X,Y の座標値を持ちます。

def_w_size はグラフィックの横幅です。

def_h_size はグラフィックの縦幅です。

h_size は、グラフィックを３分割した値が入っています。(3回に分けて描画する)

anime_wait	は、グラフィックの表示時間です。

anime_flg は、表示時間を過ぎた後、どのような行動をするか、
dm_game_anime_main.h で定義されている以下の数値のどれかが入っています。

#define	anime_next			1	//	次のコマに進む
#define	anime_loop			2	//	ループ
#define	anime_loop_infinity	3	//	無間ループ
#define	anime_stop			4	//	停止
#define	anime_end			-1	//	基本に戻る

//------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------
//	キャラクタ( マリオ・ノコノコ等 )の制御用構造体
typedef	struct{
	u8	cnt_charcter_no;		//	キャラクター番号(上記の DMC_???)
	u8	cnt_now_frame;			//	現在アニメーション配列の何番目を指しているか
	u8	cnt_anime_count;		//	次のアニメまでのカウンター
	u8	cnt_anime_loop_count;	//	ループ用カウンター
	s8	cnt_anime_flg;			//	フラグ
	u32	cnt_anime_address;		//	キャラクタグラフィックの読込みアドレス
	game_anime_data	**anime_charcter;	//	１キャラの全アニメーションデータの配列を指す
	game_anime_data	*cnt_now_type;		//	現在どのアニメーションをしているか
}game_anime;

上記構造体は、キャラクターのアニメーション制御用の構造体です。

cnt_charcter_no	は、下記のキャラクター番号( 0 〜 11 )が入ります。
enum	{
	DMC_MARIO,		//	0:マリオ
	DMC_NOKO,		//	1:ノコノコ
	DMC_BOM,		//	2:ボム兵
	DMC_PUKU,		//	3:プクプク
	DMC_CHORO,		//	4:チョロブー
	DMC_PRO,		//	5:プロペラヘイホー
	DMC_HANA,		//	6:ハナちゃん
	DMC_TERE,		//	7:テレサ
	DMC_PAK,		//	8:パックンフラワー
	DMC_KAME,		//	9:カメック
	DMC_KUPPA,		//	10:クッパ
	DMC_PEACH,		//	11:ピーチ姫
	DMC_KINOPIO,	//	12:キノピオ
	DMC_PINKBOM,	//	12:ピンクボムヘイ
};

cnt_now_frame は、現在表示中のアニメーションの何コマ目なのかをさします。

cnt_anime_count	は、カウンターでこの数値が anime_wait を越えると anime_flg の中身の
行動をとります。

cnt_anime_flg は、割り込みフラグで、このフラグが 0 のときは、基本的に他のアニメーションに
変更できません。

cnt_anime_address は、グラフィックデータの読込み先アドレスをもちます。

anime_chacter は、1 キャラクターの全アニメーション( WIN・LOSE 等)を一まとめにした配列の
先頭のアドレスをさします。

cnt_now_type は、アニメーション( WIN・LOSE 等)の１アニメーションを一まとめにした配列の
先頭のアドレスをさします。


図にすると下記のように生ります

		anime_chacter					cnt_now_type

			↓								↓

	[ マリオアニメーション ] ----- [ ＷＩＮ   アニメーション ]
							 |
							 |---- [ ＬＯＳＥ アニメーション ]
							 |
							 |---- [ ＤＲＡＷ アニメーション ] ----- [ １コマ目 ]
															   |
															   |---- [ ２コマ目 ]
															   |
															   |---- [ ３コマ目 ]


//------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------
//	ゲームの制御用構造体
typedef	struct	{
	u32	game_score;			//	得点
	u16	game_retry;			//	リトライ
	s16	map_x,map_y;		//	マップの座標
	s8	map_item_size;		//	マップのアイテムの大きさ
	u8	game_mode[2];		//	0:内部処理番号 1:内部処理番号保存変数
	s8	game_condition[4];	//	0:その時の状態 2:その時の状態保存変数 3:変化しない状況変数(トレーニング中だと０以外) 4:不変的状態 win lose pause wait のいずれかが入る
	u8	virus_number;		//	ウイルス数
	u8	virus_level;		//	ウイルスレベル
	u8	virus_anime;		//	ウイルスアニメーション番号
	s8	virus_anime_vec;	//	ウイルスアニメーション進行方向
	u8	virus_anime_count;	//	ウイルスアニメーションカウンタ
	u8	virus_anime_max;	//	ウイルスアニメーションの最大コマ数
	u8	virus_anime_spead;	//	ウイルスアニメーション速度
	u8	cap_def_speed;		//	カプセル速度(SPEED_?(LOW/MID/HIGH/MAX))
	u8	cap_speed;			//	カプセル速度
	u8	cap_count;			//	カプセル落下数
	u8	cap_speed_count;	//	カプセル落下用カウンタ
	u8	cap_speed_vec;		//	カプセル落下用カウンタ増加値
	u8	cap_speed_max;		//	カプセル落下速度(カウンタがこの数値以上になると１段落下)
	u8	cap_magazine_cnt;	//	カプセルマガジン参照用変数
	u8	cap_magazine_save;	//	カプセルマガジン参照用保存変数
	s8	cap_move_se_flg;	//	カプセル左右移動時のＳＥを鳴らすためのフラグ
	u8	erase_anime;		//	消滅アニメーションコマ数
	u8	erase_anime_count;	//	消滅アニメーションカウンタ	//	粒落下のカウンタも兼ねる
	u8	erase_virus_count;	//	消滅ウイルス数
	u8	chain_count;		//	連鎖数
	u8	chain_line;			//	消滅列数
	u8	max_chain_line;		//	最大消滅列数
	u8	chain_color[4];		//	0: 赤 1:黄 2:青 消した色をカウントする。 3: 連鎖開始時に消した色のビットを立てる 0x01:赤 0x02:黄 0x04:青 ウイルス含む場合 0x80 のビットを立てる
	u8	warning_flg;		//	警戒音とうを鳴らすためのフラグ (ビットで制御する) 0x08:ウイルスラスト３ 0x80 積み上げすぎ
	u8	work_flg;			//	汎用性フラグ
	u8	retire_flg[3];		//	リタイアフラグ
	u8	player_state[5];	//	0:TRUE == コンピュータ 1:LEVEL(0.1.2); 2:プレイヤー番号 3:敵思考キャラ 4:敵・味方識別フラグ
#ifdef	DAMAGE_TYPE
	u16	cap_attack_work[DAMAGE_MAX][2];	//	0:自分に落下する攻撃カプセルのワーク(2bitで制御,01:赤,10:黄,11:青,00:無し) 1:攻撃してきた相手
#endif
#ifndef	DAMAGE_TYPE
	u8	cap_attack_work[DAMAGE_MAX][6];	//	自分に落下する攻撃カプセルのワーク
#endif
	game_anime	anime;		//	アニメーション制御
	game_cap	now_cap;	//	現在操作するカプセル
	game_cap	next_cap;	//	次のカプセル
	AIWORK	ai;			// COM思考用ﾜｰｸ
	u8		pn;			// ﾌﾟﾚｲﾔｰ no.
	u8		gs;			// ｹﾞｰﾑｽﾃｰﾀｽ
	u8		lv;			// 設定ﾚﾍﾞﾙ(0-29)
	u8		vs;			// ｳｲﾙｽ残数(ｶｳﾝﾀではなく、毎ｲﾝﾄごとにﾏｯﾌﾟﾃﾞｰﾀ上から探した数字が入る)
	u8		pu[3];		// 0:TRUE==ｺﾝﾋﾟｭｰﾀ, 1:LEVEL( 0,1,2 ), 2:ﾃﾞﾓ no.
	AIBLK	blk[STD_MFieldY+1][STD_MFieldX];//ﾌﾞﾛｯｸﾜｰｸ
	AICAPS	cap;
}game_state;

上記構造体は、PWORK のかわりのようなものです。

下記のメンバー変数は、内部制御に関するものです。
game_score				得点です。
map_x,map_y;			瓶の座標( 瓶の黒い部分の左端Ｘ座標 と 一番上のＹ座標 )が入ります。
map_item_size;			アイテムの大きさ( 10 か 8 )がはいります。
game_mode[2]			内部処理番号で game_main.h で宣言されている dm_mode_???? の値がはいります。
						配列の１番目が 現在の値、配列の２番目がポーズのときに game_mode の値を保存するためにつかいます。

game_condition[4] 		内部処理番号で game_main.h で宣言されている dm_cnd_???? の値がはいります。
						配列の１番目が 現在の値、配列の２番目がポーズのときに game_condition の値を保存するためにつかいます。
						配列の３番目は、４ＰＬＡＹのときの練習のときにフラグが立ちます。
						配列の４番目は、絶対的状態(通常・ポーズ・勝ち・負け・ゲームオーバー)しか入らず、判別用に用いられます。

下記のメンバー変数は、ウイルスに関するものです。
virus_number			ウイルス数
virus_level				ウイルスレベル
virus_anime				ウイルスアニメーション番号
virus_anime_vec			ウイルスアニメーション進行方向
virus_anime_count		ウイルスアニメーションカウンタ
virus_anime_max			ウイルスアニメーションの最大コマ数 ( virus_anime が この数値を超えると virus_anime_vec が逆転します )
virus_anime_spead		ウイルスアニメーション速度 ( virus_anime_count が この数値を越えると virus_anime が virus_anime_vec( 1 か -1 ) だけすすみます )

下記のメンバー変数は、カプセル制御に関するものです
cap_def_speed;			カプセル速度(SPEED_?(LOW/MID/HIGH/MAX))
cap_speed;				カプセル速度
cap_count;				カプセル落下数 ( この値が 10 を越えると カプセル速度( cap_speed )が１段階上がります )
cap_speed_count;		カプセル落下用カウンタ
cap_speed_vec;			カプセル落下用カウンタ増加値 ( cap_speed_count に足される値 )
cap_speed_max;			カプセル落下速度(カウンタがこの数値以上になると１段落下)
cap_magazine_cnt;		カプセルマガジン参照用変数	   ( 次に落下するカプセルのマガジン位置 )
cap_magazine_save;		カプセルマガジン参照用保存変数 ( 現在落下中のカプセルのマガジン位置 )
cap_attack_work[DAMAGE_MAX];		自分に落下する攻撃カプセルのワーク(2bitで制御,00:赤,01:黄,10:青,11:無し)この配列の 0 番が 0x0000 のときは、攻撃無し
now_cap;				現在操作中のカプセル情報
next_cap;				次に操作するのカプセル情報

下記のメンバー変数は、消滅アニメーションに関するものです
erase_anime;			消滅アニメーションコマ数
erase_anime_count;		消滅アニメーションカウンタで粒落下のカウンタも兼ねる
erase_virus_count;		消滅ウイルス数

下記のメンバー変数は、連鎖に関するものです
chain_count;			連鎖数
chain_line;				消滅列数
chain_color[4];			消した色で攻撃のときに使用します。(ビットで制御する)	0x01:赤	0x02:黄 0x04:青 0x08:ウイルスを含む消滅の場合立てる

下記のメンバー変数は、その他の制御に関するものです
warning_flg;			警戒音等を鳴らすためのフラグ (ビットで制御する) 0x08:ウイルスラスト３ 0x80 積み上げすぎ
work_flg;				汎用性フラグ
retire_flg[3];			リタイアフラグ 0:リタイアした直後にフラグが立ちます。 1:黒上がりが終了したときにフラグが立ちます。 2:攻撃ありの練習を選んだときにフラグが立ちます。
player_state[5];		0:PUF_PlayerMAN == MAN PUF_PlayerCPU == コンピュータ 1:LEVEL(0.1.2); 2:プレイヤー番号 3:思考キャラクタ番号(CHR_???) 4:チーム分けフラグ
anime;					アニメーション制御につかいます。

下記のメンバー変数は、AIの制御に関するものです

ai;								COM思考用ﾜｰｸ
pn;								ﾌﾟﾚｲﾔｰ no.
gs;								ｹﾞｰﾑｽﾃｰﾀｽ
lv;								設定ﾚﾍﾞﾙ(0-29)
vs;								ｳｲﾙｽ残数(ｶｳﾝﾀではなく、毎ｲﾝﾄごとにﾏｯﾌﾟﾃﾞｰﾀ上から探した数字が入る)
pu[3];							0:TRUE==ｺﾝﾋﾟｭｰﾀ, 1:LEVEL( 0,1,2 ), 2:ﾃﾞﾓ no.
blk[STD_MFieldY][STD_MFieldX];	ﾌﾞﾛｯｸﾜｰｸ
cap;

//------------------------------------------------------------------------------------

